<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Lber (ldap.Lber)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">ldap</a> &#x00BB; Lber</nav><h1>Module <code>Lber</code></h1><p>This library implements the subset of ber</p></header><dl><dt class="spec exception" id="exception-Decoding_error"><a href="#exception-Decoding_error" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Decoding_error</span> <span class="keyword">of</span> string</code></dt><dt class="spec exception" id="exception-Encoding_error"><a href="#exception-Encoding_error" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Encoding_error</span> <span class="keyword">of</span> string</code></dt></dl><dl><dt class="spec type" id="type-readbyte_error"><a href="#type-readbyte_error" class="anchor"></a><code><span class="keyword">type</span> readbyte_error</code><code> = </code><table class="variant"><tr id="type-readbyte_error.End_of_stream" class="anchored"><td class="def constructor"><a href="#type-readbyte_error.End_of_stream" class="anchor"></a><code>| </code><code><span class="constructor">End_of_stream</span></code></td></tr><tr id="type-readbyte_error.Transport_error" class="anchored"><td class="def constructor"><a href="#type-readbyte_error.Transport_error" class="anchor"></a><code>| </code><code><span class="constructor">Transport_error</span></code></td></tr><tr id="type-readbyte_error.Peek_error" class="anchored"><td class="def constructor"><a href="#type-readbyte_error.Peek_error" class="anchor"></a><code>| </code><code><span class="constructor">Peek_error</span></code></td></tr><tr id="type-readbyte_error.Request_too_large" class="anchored"><td class="def constructor"><a href="#type-readbyte_error.Request_too_large" class="anchor"></a><code>| </code><code><span class="constructor">Request_too_large</span></code></td></tr><tr id="type-readbyte_error.Not_implemented" class="anchored"><td class="def constructor"><a href="#type-readbyte_error.Not_implemented" class="anchor"></a><code>| </code><code><span class="constructor">Not_implemented</span></code></td></tr></table></dt></dl><dl><dt class="spec exception" id="exception-Readbyte_error"><a href="#exception-Readbyte_error" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Readbyte_error</span> <span class="keyword">of</span> <a href="index.html#type-readbyte_error">readbyte_error</a></code></dt></dl><dl><dt class="spec type" id="type-readbyte"><a href="#type-readbyte" class="anchor"></a><code><span class="keyword">type</span> readbyte</code><code> = <span>?&#8288;peek:bool</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> string</code></dt><dt class="spec type" id="type-writebyte"><a href="#type-writebyte" class="anchor"></a><code><span class="keyword">type</span> writebyte</code><code> = char <span>&#45;&gt;</span> unit</code></dt><dt class="spec type" id="type-ber_class"><a href="#type-ber_class" class="anchor"></a><code><span class="keyword">type</span> ber_class</code><code> = </code><table class="variant"><tr id="type-ber_class.Universal" class="anchored"><td class="def constructor"><a href="#type-ber_class.Universal" class="anchor"></a><code>| </code><code><span class="constructor">Universal</span></code></td></tr><tr id="type-ber_class.Application" class="anchored"><td class="def constructor"><a href="#type-ber_class.Application" class="anchor"></a><code>| </code><code><span class="constructor">Application</span></code></td></tr><tr id="type-ber_class.Context_specific" class="anchored"><td class="def constructor"><a href="#type-ber_class.Context_specific" class="anchor"></a><code>| </code><code><span class="constructor">Context_specific</span></code></td></tr><tr id="type-ber_class.Private" class="anchored"><td class="def constructor"><a href="#type-ber_class.Private" class="anchor"></a><code>| </code><code><span class="constructor">Private</span></code></td></tr></table></dt><dt class="spec type" id="type-ber_length"><a href="#type-ber_length" class="anchor"></a><code><span class="keyword">type</span> ber_length</code><code> = </code><table class="variant"><tr id="type-ber_length.Definite" class="anchored"><td class="def constructor"><a href="#type-ber_length.Definite" class="anchor"></a><code>| </code><code><span class="constructor">Definite</span> <span class="keyword">of</span> int</code></td></tr><tr id="type-ber_length.Indefinite" class="anchored"><td class="def constructor"><a href="#type-ber_length.Indefinite" class="anchor"></a><code>| </code><code><span class="constructor">Indefinite</span></code></td></tr></table></dt><dt class="spec type" id="type-ber_val_header"><a href="#type-ber_val_header" class="anchor"></a><code><span class="keyword">type</span> ber_val_header</code><code> = </code><code>{</code><table class="record"><tr id="type-ber_val_header.ber_class" class="anchored"><td class="def field"><a href="#type-ber_val_header.ber_class" class="anchor"></a><code>ber_class : <a href="index.html#type-ber_class">ber_class</a>;</code></td></tr><tr id="type-ber_val_header.ber_primitive" class="anchored"><td class="def field"><a href="#type-ber_val_header.ber_primitive" class="anchor"></a><code>ber_primitive : bool;</code></td></tr><tr id="type-ber_val_header.ber_tag" class="anchored"><td class="def field"><a href="#type-ber_val_header.ber_tag" class="anchor"></a><code>ber_tag : int;</code></td></tr><tr id="type-ber_val_header.ber_length" class="anchored"><td class="def field"><a href="#type-ber_val_header.ber_length" class="anchor"></a><code>ber_length : <a href="index.html#type-ber_length">ber_length</a>;</code></td></tr></table><code>}</code></dt></dl><dl><dt class="spec value" id="val-readbyte_of_string"><a href="#val-readbyte_of_string" class="anchor"></a><code><span class="keyword">val</span> readbyte_of_string : string <span>&#45;&gt;</span> <a href="index.html#type-readbyte">readbyte</a></code></dt><dd><p>return a readbyte function for a string, currently not implemented</p></dd></dl><dl><dt class="spec value" id="val-readbyte_of_ber_element"><a href="#val-readbyte_of_ber_element" class="anchor"></a><code><span class="keyword">val</span> readbyte_of_ber_element : <a href="index.html#type-ber_length">ber_length</a> <span>&#45;&gt;</span> <a href="index.html#type-readbyte">readbyte</a> <span>&#45;&gt;</span> <a href="index.html#type-readbyte">readbyte</a></code></dt><dd><p>return a readbyte implementation which uses another readbyte, but allows setting a read boundry. Useful for constructing views of the octet stream which end at the end of a ber structure. This is essential for reading certian structures because length is only encoded in the toplevel in order to save space. Currently only implemented for definite lengths.</p><dl><dt>raises Readbyte_error</dt><dd><p>in the event of a an io error, or the end of file</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-readbyte_of_fd"><a href="#val-readbyte_of_fd" class="anchor"></a><code><span class="keyword">val</span> readbyte_of_fd : Unix.file_descr <span>&#45;&gt;</span> <a href="index.html#type-readbyte">readbyte</a></code></dt><dd><p>a readbyte implementation which reads from an FD. It implements a peek buffer, so it can garentee that it will work with rb_of_ber_element, even with blocking fds.</p><dl><dt>raises Readbyte_error</dt><dd><p>in the event of a an io error, or the end of file</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-readbyte_of_ssl"><a href="#val-readbyte_of_ssl" class="anchor"></a><code><span class="keyword">val</span> readbyte_of_ssl : Ssl.socket <span>&#45;&gt;</span> <a href="index.html#type-readbyte">readbyte</a></code></dt><dd><p>a readbyte implementation which reads from an SSL socket. It is otherwise the same as readbyte_of_fd.</p><dl><dt>raises Readbyte_error</dt><dd><p>in the event of a an io error, or the end of file</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-decode_ber_header"><a href="#val-decode_ber_header" class="anchor"></a><code><span class="keyword">val</span> decode_ber_header : <span>?&#8288;peek:bool</span> <span>&#45;&gt;</span> <a href="index.html#type-readbyte">readbyte</a> <span>&#45;&gt;</span> <a href="index.html#type-ber_val_header">ber_val_header</a></code></dt><dd><p>decoding and encoding of the ber header</p></dd></dl><dl><dt class="spec value" id="val-encode_ber_header"><a href="#val-encode_ber_header" class="anchor"></a><code><span class="keyword">val</span> encode_ber_header : <a href="index.html#type-ber_val_header">ber_val_header</a> <span>&#45;&gt;</span> string</code></dt><dt class="spec value" id="val-read_contents"><a href="#val-read_contents" class="anchor"></a><code><span class="keyword">val</span> read_contents : <span>?&#8288;peek:bool</span> <span>&#45;&gt;</span> <a href="index.html#type-readbyte">readbyte</a> <span>&#45;&gt;</span> <a href="index.html#type-ber_length">ber_length</a> <span>&#45;&gt;</span> string</code></dt><dd><p>reads the contents octets</p></dd></dl><aside><p>ENCODING and DECODING Functions</p><p>Explanation of optional arguments: The optional arguments are there to deal with a number of situations, cls, and tag are for context specific or application situations where it is expected that the value will not be marked with the class and tag defined in X.680. Contents is there for akward situations which arise because of the choice structure. Normally the decode functions will always read the header for you, however with the choice structure this is impossible. In this case you should read the header manually, determine which decode function to call, unpack the contents with read_contents, and send them in the contents optional. If contents is not None, then readbyte will never be called, and no attempt will be made to read the header or length.</p></aside><dl><dt class="spec value" id="val-decode_ber_bool"><a href="#val-decode_ber_bool" class="anchor"></a><code><span class="keyword">val</span> decode_ber_bool : <span>?&#8288;peek:bool</span> <span>&#45;&gt;</span> <span>?&#8288;cls:<a href="index.html#type-ber_class">ber_class</a></span> <span>&#45;&gt;</span> <span>?&#8288;tag:int</span> <span>&#45;&gt;</span> <span>?&#8288;contents:<span>string option</span></span> <span>&#45;&gt;</span> <a href="index.html#type-readbyte">readbyte</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Encoding/Decoding of the boolean primative ASN.1 type. Encode function encodes a valid ber type, including the header and length octets.</p></dd></dl><dl><dt class="spec value" id="val-encode_ber_bool"><a href="#val-encode_ber_bool" class="anchor"></a><code><span class="keyword">val</span> encode_ber_bool : <span>?&#8288;cls:<a href="index.html#type-ber_class">ber_class</a></span> <span>&#45;&gt;</span> <span>?&#8288;tag:int</span> <span>&#45;&gt;</span> bool <span>&#45;&gt;</span> string</code></dt><dt class="spec value" id="val-decode_ber_int32"><a href="#val-decode_ber_int32" class="anchor"></a><code><span class="keyword">val</span> decode_ber_int32 : <span>?&#8288;peek:bool</span> <span>&#45;&gt;</span> <span>?&#8288;cls:<a href="index.html#type-ber_class">ber_class</a></span> <span>&#45;&gt;</span> <span>?&#8288;tag:int</span> <span>&#45;&gt;</span> <span>?&#8288;contents:<span>string option</span></span> <span>&#45;&gt;</span> <a href="index.html#type-readbyte">readbyte</a> <span>&#45;&gt;</span> int32</code></dt><dd><p>Encoding/Decoding of the integer primative ASN.1 type. Note, in this library, integers are represented as 32 bit values. In ASN.1 there is no practical limit to the size of an integer, later on, this library may provide an encoder/decoder to Int64, and Bigints, however for now, this will have to do. Encode function encodes a valid ber type, including the header and length octets</p></dd></dl><dl><dt class="spec value" id="val-encode_ber_int32"><a href="#val-encode_ber_int32" class="anchor"></a><code><span class="keyword">val</span> encode_ber_int32 : <span>?&#8288;cls:<a href="index.html#type-ber_class">ber_class</a></span> <span>&#45;&gt;</span> <span>?&#8288;tag:int</span> <span>&#45;&gt;</span> int32 <span>&#45;&gt;</span> string</code></dt><dt class="spec value" id="val-decode_ber_enum"><a href="#val-decode_ber_enum" class="anchor"></a><code><span class="keyword">val</span> decode_ber_enum : <span>?&#8288;peek:bool</span> <span>&#45;&gt;</span> <span>?&#8288;cls:<a href="index.html#type-ber_class">ber_class</a></span> <span>&#45;&gt;</span> <span>?&#8288;tag:int</span> <span>&#45;&gt;</span> <span>?&#8288;contents:<span>string option</span></span> <span>&#45;&gt;</span> <a href="index.html#type-readbyte">readbyte</a> <span>&#45;&gt;</span> int32</code></dt><dd><p>Encoding/Decoding of enum primative ASN.1 type. Enums are simply integers, the same drawbacks apply as for decode_ber_int32. Encode function encodes a valid ber type, including the header and length octets</p></dd></dl><dl><dt class="spec value" id="val-encode_ber_enum"><a href="#val-encode_ber_enum" class="anchor"></a><code><span class="keyword">val</span> encode_ber_enum : <span>?&#8288;cls:<a href="index.html#type-ber_class">ber_class</a></span> <span>&#45;&gt;</span> <span>?&#8288;tag:int</span> <span>&#45;&gt;</span> int32 <span>&#45;&gt;</span> string</code></dt><dt class="spec value" id="val-decode_ber_octetstring"><a href="#val-decode_ber_octetstring" class="anchor"></a><code><span class="keyword">val</span> decode_ber_octetstring : <span>?&#8288;peek:bool</span> <span>&#45;&gt;</span> <span>?&#8288;cls:<a href="index.html#type-ber_class">ber_class</a></span> <span>&#45;&gt;</span> <span>?&#8288;tag:int</span> <span>&#45;&gt;</span> <span>?&#8288;contents:<span>string option</span></span> <span>&#45;&gt;</span> <a href="index.html#type-readbyte">readbyte</a> <span>&#45;&gt;</span> string</code></dt><dd><p>Encoding/Decoding of octetstring ASN.1 types. The Nested or &quot;segmented&quot; version of the octetstring encoding described in X.690 is not yet supported. Encode function encodes a valid ber type, including the header and length octets</p></dd></dl><dl><dt class="spec value" id="val-encode_ber_octetstring"><a href="#val-encode_ber_octetstring" class="anchor"></a><code><span class="keyword">val</span> encode_ber_octetstring : <span>?&#8288;cls:<a href="index.html#type-ber_class">ber_class</a></span> <span>&#45;&gt;</span> <span>?&#8288;tag:int</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string</code></dt><dt class="spec value" id="val-decode_ber_null"><a href="#val-decode_ber_null" class="anchor"></a><code><span class="keyword">val</span> decode_ber_null : <span>?&#8288;peek:bool</span> <span>&#45;&gt;</span> <span>?&#8288;cls:<a href="index.html#type-ber_class">ber_class</a></span> <span>&#45;&gt;</span> <span>?&#8288;tag:int</span> <span>&#45;&gt;</span> <span>?&#8288;contents:<span>string option</span></span> <span>&#45;&gt;</span> <a href="index.html#type-readbyte">readbyte</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Encoding/Decoding of Null ASN.1 type. Almost useful as an assertion-type operation</p></dd></dl><dl><dt class="spec value" id="val-encode_ber_null"><a href="#val-encode_ber_null" class="anchor"></a><code><span class="keyword">val</span> encode_ber_null : <span>?&#8288;cls:<a href="index.html#type-ber_class">ber_class</a></span> <span>&#45;&gt;</span> <span>?&#8288;tag:int</span> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> string</code></dt><dt class="spec value" id="val-encode_berval_list"><a href="#val-encode_berval_list" class="anchor"></a><code><span class="keyword">val</span> encode_berval_list : <span>?&#8288;buf:Stdlib.Buffer.t</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> string)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> string</code></dt><dd><p>this function is for encoding lists of bervals, a common case. you pass it a list of things to encode, and an encoding function, and it will apply the encoding function to each element in the list, storing the resulting encoding in a buffer (which you may either pass in or not)</p></dd></dl><dl><dt class="spec value" id="val-decode_berval_list"><a href="#val-decode_berval_list" class="anchor"></a><code><span class="keyword">val</span> decode_berval_list : <span>?&#8288;lst:<span><span class="type-var">'a</span> list</span></span> <span>&#45;&gt;</span> <span>(<a href="index.html#type-readbyte">readbyte</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <a href="index.html#type-readbyte">readbyte</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p>this is the reverse of the above, it takes a readbyte structure, and returns a list of decoded elements, processed according to the decoder function you pass in. Note, that you MUST pass a readbyte structure built with readbyte_of_string, OR, your reabyte function must raise Stream.Failure when you reach the end of input. Otherwise this function will explode. That said, it is usually not practical to pass anything but a readbyte created by readbyte_of_string so this should not be a huge problem.</p></dd></dl></div></body></html>